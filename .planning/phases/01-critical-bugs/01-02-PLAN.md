---
phase: 01-critical-bugs
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/models/destination.py
autonomous: true

must_haves:
  truths:
    - "User can delete any destination from a trip without errors"
    - "Deleting a destination removes all associated travel segments"
    - "Frontend state updates correctly after deletion"
  artifacts:
    - path: "app/models/destination.py"
      provides: "Destination model with cascade relationships for travel segments"
      contains: "travel_segments_from"
  key_links:
    - from: "app/models/destination.py"
      to: "TravelSegment.from_destination_id"
      via: "SQLAlchemy relationship with cascade"
      pattern: "relationship.*TravelSegment.*cascade"
    - from: "frontend/src/stores/useDestinationStore.js"
      to: "DELETE /destinations/{id}"
      via: "fetch DELETE request"
      pattern: "DELETE.*destinations"
---

<objective>
Fix destination deletion cascade issue (BUG-01) by ensuring SQLAlchemy properly cascades deletions to related TravelSegment records.

Purpose: Enable users to delete destinations without database constraint violations or orphaned records.
Output: Working destination deletion that properly cascades to all related entities.
</objective>

<execution_context>
@/Users/adrihp06/.claude/get-shit-done/workflows/execute-plan.md
@/Users/adrihp06/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-critical-bugs/01-RESEARCH.md

# Model files
@app/models/destination.py
@app/models/travel_segment.py

# API and store files for verification
@app/api/destinations.py
@frontend/src/stores/useDestinationStore.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add travel segment cascade relationships to Destination model</name>
  <files>app/models/destination.py</files>
  <action>
Add missing relationship definitions to the Destination model for TravelSegment backrefs.

The TravelSegment model has two foreign keys to Destination:
- `from_destination_id` (with ondelete="CASCADE")
- `to_destination_id` (with ondelete="CASCADE")

While database CASCADE handles deletion at the SQL level, SQLAlchemy's session state can become inconsistent without proper relationship definitions.

Add these relationships to the Destination class (after the existing relationships around line 29):

```python
# Travel segment relationships for proper cascade handling
travel_segments_from = relationship(
    "TravelSegment",
    foreign_keys="TravelSegment.from_destination_id",
    back_populates="from_destination",
    cascade="all, delete-orphan",
    passive_deletes=True
)
travel_segments_to = relationship(
    "TravelSegment",
    foreign_keys="TravelSegment.to_destination_id",
    back_populates="to_destination",
    cascade="all, delete-orphan",
    passive_deletes=True
)
```

Then verify TravelSegment model has corresponding back_populates. If not present, add:
```python
# In travel_segment.py
from_destination = relationship("Destination", foreign_keys=[from_destination_id], back_populates="travel_segments_from")
to_destination = relationship("Destination", foreign_keys=[to_destination_id], back_populates="travel_segments_to")
```

Notes:
- `passive_deletes=True` tells SQLAlchemy to trust the database CASCADE
- `cascade="all, delete-orphan"` ensures SQLAlchemy session stays consistent
- This mirrors the existing pattern for `pois` and `accommodations` relationships
  </action>
  <verify>
1. Check relationship definitions compile: `docker-compose exec backend python -c "from app.models.destination import Destination; print('OK')"`
2. Check TravelSegment compiles: `docker-compose exec backend python -c "from app.models.travel_segment import TravelSegment; print('OK')"`
3. Run existing tests: `docker-compose exec backend pytest app/tests/api/test_destinations.py -v` (if exists)
  </verify>
  <done>Destination model has travel_segments_from and travel_segments_to relationships with cascade configured</done>
</task>

<task type="auto">
  <name>Task 2: Verify and test destination deletion end-to-end</name>
  <files>app/api/destinations.py, frontend/src/stores/useDestinationStore.js</files>
  <action>
Verify the deletion flow works end-to-end with the new relationships.

1. Review the DELETE endpoint in app/api/destinations.py (around line 143):
   - Confirm it returns 204 on success
   - Confirm it raises 404 for missing destinations
   - No changes needed unless logging is missing

2. Review the frontend store deleteDestination in useDestinationStore.js (around line 101):
   - Confirm it handles 204 response correctly
   - Confirm it updates local state after successful deletion
   - No changes needed unless error handling is insufficient

3. Test the complete flow:
   - Create a test destination with travel segments (via API or UI)
   - Attempt to delete the destination
   - Verify no 500 errors, no constraint violations
   - Verify related travel segments are also deleted

If the existing code is correct (likely), this task confirms the fix worked.
If issues found, document them and fix.
  </action>
  <verify>
1. Start the application: `docker-compose up -d`
2. Open browser to trip detail view with destinations
3. Select a destination that has travel segments
4. Click delete button
5. Confirm deletion succeeds (destination removed from UI)
6. Verify no errors in backend logs: `docker-compose logs -f backend`
7. Optional: Check database directly to confirm travel segments were cascaded
  </verify>
  <done>Destination deletion works without errors; travel segments cascade properly; frontend updates state</done>
</task>

</tasks>

<verification>
1. Model compiles without errors
2. DELETE /destinations/{id} returns 204 (not 500)
3. Related TravelSegments are deleted (no orphans)
4. Frontend state updates correctly after deletion
5. No console errors in frontend, no exceptions in backend logs
</verification>

<success_criteria>
- BUG-01: User can delete any destination without errors
- Cascade deletion removes related travel segments
- Frontend reflects deletion immediately
- Backend logs show clean deletion (no constraint violations)
</success_criteria>

<output>
After completion, create `.planning/phases/01-critical-bugs/01-02-SUMMARY.md`
</output>
